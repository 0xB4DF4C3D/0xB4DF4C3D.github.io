---
layout: "post"
title: "객체지향 설계 5원칙 SOLID"
date: "2018-03-11 23:01"
categoty: [Programming, TOPCIT]
---

# 객체지향 설계 5원칙 SOLID

- SRP(the Single Responsibility Principle, 단일 책임의 원칙)<br>
> 하나의 클래스는 하나의 method만을 갖게 됨에 따라 수정에 대한 이유는 한가지가 되어야 한다.
> 그러나, 실제 환경에서는 문제가 복잡하고 거대화 됨에 따라 사용은 어려운 문제가 되며, 유틸리티와 같은
> 형태로 적용하는 것이 좋다.

<br>
- OCP(the Open Close Principle, 개방 폐쇄의 원칙)<br>
> 하나의 클래스는 수정에 폐쇄되어 있고, 확장에 개방되어 있어야 한다. 이는 객체지향의 대표적
> 특징인 다형성과 추상화에 관련된 내용이며, 기능 개선 시 직접적인 수정보다는 상속을 통한 개선이 이루어지는
> 것이 좋다. 또한, 로직 변경 가능 여부를 고려한 추상화 클래스 구현이 되어야 한다.

<br>
- LSP(the Liskov Substitution Principle, 리스코프 치환의 원칙)<br>
> 상속을 위한 설계 중에서 가장 중요한 원칙으로 상속을 하게 되는 경우 IS-A 관계가 성립하기 때문에 지켜져야
> 하는 원칙이다. 즉, 하위클래스는 언제나 상위클래스로 참조가 가능한 상속과 관련된 원칙이다.

<br>
- ISP(the Interface Segregation Principle, 인터페이스 분리의 원칙)<br>
> 노출된 객체의 인터페이스를 통해 객체간 커뮤니케이션이 일어나는데 이 노출 방법에 대한 원칙으로 사용자
> 별로 다른 방식의 인터페이스를 제공토록 설계해야 한다. 일반사용자와 관리자에게 주어지는 인터페이스는
> 달라야 함을 예로 생각해 볼 수 있다.

<br>
- DIP(the Dependency Inversion Principle, 의존성 역전의 원칙)<br>
> 사용하는 클래스와 사용되는 클래스가 있을 때 사용되는 클래스의 인터페이스가 변경될 경우 사용하는
> 클래스도 변경부분에 대한 확인을 해야 하는 의존성이 갖게 된다. 사소한 부분이라도 수정이 발생될 경우
> 이에 대한 완전성과 무결성에 대한 보장은 어려운 것이 현실이다. 따라서, 이러한 변경 가능성을 최소화
> 하기 위하여 인터페이스를 통한 추상화를 통해 최대한 느슨하게 설계하자는 원칙이다.

---

음... 솔직히 잘 모르겠다. 뭔가 감이 안온다. 그래서 위키도 참고 했다. 하나씩 검색해보았다.

# Single responsibility principle 단일 책임의 원칙
단일 책임의 원칙은 모든 모듈이나 클래스는 소프트웨어에서 제공하는 기능 중 단 하나의 기능만을 제공할 책임을 가져야 하며 책임은 클래스에 의해 전부 캡슐화되어야 한다는 원칙이다. 그것의 모든 서비스들은 그 책임을 통해 주의깊게 맞춰져야 한다. Robert C. Martin은 이 원칙을 `클래스는 변경할 이유를 단 하나만 가져야 한다` 라고 표현했다.

## 예
Martin은 책임을 _변경할 이유_ 라고 정의했고 클래스나 모듈들은 변경되기 위해(또는 재작성) 단 하나의 이유만을 가져야 한다고 결론 내렸다. 예로써, 보고서를 편집하고 출력하는 모듈을 생각해보자. 그런 모듈은 두가지 이유로 인해 변경될 수 있다는걸 상상해보자. 첫째, 보고서의 내용이 변할 수 있다. 둘째, 보고서의 서식이 변경될 수 있다. 이 두 가지 변경은 매우 다른 원인들로 변환된다; 실질적인 것, 허울뿐인 것. 단일 책임의 원칙은 이 문제의 두 측면이 정말로 두개로 분리된 책임들이며 따라서 분리된 클래스나 모듈에 의해 나뉘어져야 한다는 것이다. 다른 시간에 다른 이유로 변경하는 두 가지를 엮는 것은 나쁜 디자인 일것이다.

클래스가 하나의 책임에만 집중하도록 하는 것이 중요한 이유는 클래스를 더 견고하게 만들기 때문이다. 앞서 나온 예제에서, 보고서 편집 과정에 변경이 생긴다면, 같은 클래스의 일부인 출력 코드가 깨질 위험이 생길 수 있다.

<br><br>
# Open/Closed Principle 개방 폐쇄의 원칙
객체 지향 프로그래밍에서, 개방 폐쇄의 원칙은 "_소프트웨어 개체들(클래스, 모듈, 함수 등등)은 확장에는 열려있지만 변경에는 닫혀있어야 한다_" 라는 것이다. 즉, 그러한 개체들은 그것의 소스 코드를 변경하지 않고도 그것의 작동 방식을 확장시킬 수 있다.

개방 폐쇄의 원칙이라는 이름은 두 가지 방법으로 쓰이고 있다. 두 방법 모두 상속을 사용하여 표현의 딜레마를 해결하는데 목적, 기술 그리고 결과는 서로 다르다.

## Meyer의 개방 폐쇄의 원칙
Bertrand Meyer는 일반적으로 그의 1988년도 책 _객체 지향 소프트웨어 구축_ 에서 나온 용어 _개방 폐쇄의 원칙_ 의 창시자로써 유명하다.
- 만약 여전히 확장이 가능 하다면, 모듈은 열려있어야 한다. 예를 들면, 그것은 그것이 포함하고 있는 자료구조에 필드나 그것이 수행하는 기능들의 집합에 새로운 요소를 추가하는게 가능해야 한다.
- 만약 다른 모듈에서 사용이 가능 하다면, 모듈은 닫혀있어야 한다. 이는 그 모듈이 잘 정의되었고, 안정적임을 의미한다. 

Meyer가 집필할 당시엔, 라이브러리에 필드나 기능을 추가하는 것은 필수불가결적으로 그 라이브러리에 의존하는 모든 프로그램의 변경이 필요했었다. Meyer가 제안한 이 딜레마에 대한 해결책은 객체 지향 상속 개념(특히 구현 상속)에 기반한다:

```
클래스는 편집되고 라이브러리에 저장되고, 사용자 클래스에 
의해 사용되기에 닫혀있다. 하지만 새로운 아무 클래스나 그것
을 부모로 사용하여 새로운 기능을 추가할수 있기에 또한 열려
있다. 하위 클래스가 정의될 때, 상위 클래스를 수정하거나 그
것을 사용하는 클래스를 건드릴 필요가 없어야 한다.
```

## 다형성 개방 폐쇄의 원칙
1990년대, 개방 폐쇄의 원칙은 일반적으로 구현이 변경될 수 있으며 다중 상속이 생기고 서로를 다형성 치환할 수 있을지 모르는 추상 인터페이스의 사용을 나타내는것으로 재정의 되었다.

Meyer의 사용과 대조적으로, 이 정의는 추상 기반 클래스로부터의 상속을 옹호한다. 인터페이스 명세는 상속을 통해 재사용될 수 있지만 구현은 그렇지 않아야 한다. 기존의 인터페이스는 변경에 닫혀있고 새로운 구현은 반드시, 최소한, 그것의 인터페이스를 구현해야 한다.

<br> <br>
# 리스코프 치환의 원칙
대용 가능성(Substitutability 代用可能性)이란 말은 컴퓨터 프로그래밍에서 만약 자료형 S가 자료형 T의 subtype일때, T의 객체가 S의 객체로 T의 어떠한 속성들(정확성, 수행업무 등)도 변경하지 않고 치환할 수 있어야 한다는 원칙이다. 더 공식적으로, 리스코프 치환의 원칙은 1987년 _자료 추상화와 계층_ 이라는 제목으로 Barbara Liskov가 컨퍼런스에서 기조연설로 처음 소개한 (강한) behavioral subtyping이라 불리는 subtyping 관계의 특수한 정의이다. 이것은 특수한 상황의 계층, 객체 유형에서 자료형의 의미론적 상호운용성을 보장하기 때문에 그저 문법적이기보단 의미론적이다. Barbara Liskov와 Jeannette Wing은 1994년 논문에서 다음과 같이 공식을 간결하게 공식화했다:
> Subtype 필요조건 : Φ(x)가 자료형 T인 객체 x에 대해 증명할
> 수 있는 속성이라 하자. 그러면 Φ(x)는 자료형 T의 subtype이
> S일때 자료형 S의 객체 y에 대해 참이어야 한다.

같은 논문에서, Liskov와 Wing은 전제조건, 사후조건 그리고 불변을 통해 subtyping의 상호작용을 고려한 Bertand Meyer의 설계와 거의 유사하다는 호어 논리 확장에서 behavioral subtyping의 개념에 대해 자세히 설명한다.

## 원칙
Liskov의 behavioral subtype 개념은 객체의 대용가능성의 개념에 대해 정의한다; 즉, T의 subtype이 S라면, 프로그램의 자료형 T인 객체는 그 프로그램의 어떠한 속성(예로 정확성)을 변경하지 않고도 자료형 S인 객체로 대체 될 수 있어야 한다는 것이다.

Behavioral subtyping은 그저 인자의 반공변성과 반환형의 공변성에 의존하는 자료형 이론에서 정의된 일반적인 함수의 subtyping보다 더 강한 개념이다. Behavioral subtyping은 일반적으로 결정불가능하다고 증명되었다: 만약 q가 "언제나 x를 종료하는 메서드" 라는 속성일때 어떤 프로그램(예로 컴파일러)이 속성 q가 자료형 T임에도 불구하고 q가 T의 임의의 subtype S임을 보장하는 것은 불가능하다. 그렇더라도 계층적 구조 설계에 대한 추론에선 유용하다.

Liskov의 원칙은 더 새로운 객체 지향 프로그래밍 언어(보통 자료형보다는 클래스 수준에서, 비교를 위해 [nominal vs. structural subtyping](https://en.wikipedia.org/wiki/Subtype#Subtyping_schemes)를 볼 것)에서 적용되고 있는 signature에 몇몇 표준적인 필요조건을 요구한다:
- subtype에서 메서드 인자의 반공변성
- subtype에서 반환형의 공변성
- subtype의 메서드는 supertype의 메서드에서 던져진 예외의 subtype인 예외가 아니라면 새로운 예외를 던지지 말아야 한다.

signature 필요조건에 더해서, subtype은 반드시 다수의 behavioral 조건을 만족해야 한다. 이것들은 어떻게 계약이 상속과 상호작용할 수 있는지 가장 중요한 계약에 의한 설계라는 방법론과 유사한 용어로 자세히 설명되어 있다.

- 전제조건은 subtype을 강화 시킬 수 없다.
- 사후조건은 subtype을 약화 시킬 수 없다.
- supertype의 불변성은 subtype에서 반드시 유지되어야 한다.
- 이력 제약 조건(이력 규칙). 객체들은 오직 그것들의 메서드를 통해서만 수정이 가능하다고 여겨진다(캡슐화). subtype이 현재 supertype에는 없는 메서드를 추가할 수 있기 때문에, 추가된 메서드는 supertype에서는 허용되지 않는 subtype의 상태 변경을 허용할 수 있게 된다. 이력 제약 조건은 이를 금한다. 그것은 Liskov와 Wing에 의해 소개된 새로운 요소이다. 이 제약조건의 위반은 immutable point의 subtype으로써 mutable point를 정의하는것으로 전형적인 예가 될 수 있다. 이는 일반적으로 immutable point의 이력에서, 그 상태는 생성 후에 항상 동일하므로, mutable point의 이력을 포함할 수 없기 때문에 이력 제약 조건의 위반이다. 그러나 subtype에 추가된 필드들은 supertype의 메서드를 통해 관측이 불가능하기 때문에 안전하게 수정될 수 있다. 따라서 중심은 고정되었지만 불변에서 변경 가능한 반지름을 가진 circle 클래스를 LSP 위반없이 파생할 수 있다.

I, D는 보류.